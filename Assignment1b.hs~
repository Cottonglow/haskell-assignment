{- 
   CI285 Introduction to Functional Propgramming
   Assignment 1b
-}
module Assignment1b 
    (FreqTable, 
     HTree(..), 
     tree, fTable) 
    where

import Data.Tree -- Used for pretty-printing trees
import Data.Maybe
import Test.QuickCheck
import Data.Map
import Data.List
import Data.Ord

{- A FreqTable is a list of pairs where the first element of each pair is
an element and the second element is its frequency 
-}

type FreqTable = [(Char, Int)]

{- The data type of binary trees, HTree a, where each node
carries an int (representing frequency counts) and and leaves carry an
additional piece of data of type a (e.g. a char). A HTree is a Huffman
Tree. In a leaf node, (Leaf i c), i will represent the frequency of
occurence of c. In a branch node (Branch i l r), i will represent the
combined frquencies of the left and right children.-}

data HTree = Branch Int HTree HTree | Leaf Int Char
             deriving (Show, Eq)




{- 1. Construct the sorted frequency table for the input string.
-}

fTable :: String -> FreqTable 
fTable y = sortBy (comparing snd) (toList $ fromListWith (+) (Prelude.map (\x -> (x, 1)) y))

{- COMMENTS for 1:
1. Tuples are created from the string with frequency for each set to 1.
2. Repeating tuples are combined and the frequencies added together.
3. Converts IntMap to List.
4. Sorted in ascending order by comparing the frequency values.
-}



{- 2. Insert a HTree node into a list sorted by ascending frequency.
-}

freq :: HTree -> Int
freq (Branch n _ _) = n
freq (Leaf n _) = n

insert :: HTree -> [HTree] -> [HTree]
insert h xs = sortBy (comparing freq) (h: xs)

{- COMMENTS for 2:
1. New node is appended to list.
2. Function freq created to return the frequency value.
3. Sort new list by comparing the frequencies.
-}



{- 3. Merge a list of HTree nodes into a single Maybe HTree. If the
input is empty, return Nothing. If the input contains a single
element, we are done. Otherwise, do the following: 
  . create a Branch node from the first two elements in the input, 
  . use your insert function to insert this new element in the right place 
in the new list, which is formed of the old list without its first two elements,
  . call merge recursively on the new list

When merging two nodes, n1 and n2, the node with the lowest frequency
will be the left-hand child in the new Branch node.  
-} 

merge :: [HTree] -> Maybe HTree
merge [] = Nothing
merge [h] = Just h
merge (x:y:xs) = merge (Assignment1b.insert (Branch (freq x + freq y) x y) xs)

{- COMMENTS for 3:
1. If the input is empty, return Nothing.
2. If the input contains a single element, return Just element.
3. Otherwise create Branch node from first two elements of input. 
   Pattern matching (x:y:xs) is used to get first two elements.
4. Using the created function Insert to insert new element into the new list xs.
   Assignment1b. is needed before insert so the function from this file is used.
5. Call the function recursively on the new list.
-}



{- 4. Construct the Huffman tree for the input [a]. Return Nothing if
the input is empty.  Otherwise, do the following: 
  . construct the frequency table for str 
  . use the frequency table to create a list of Leaf nodes 
  . merge that list into a single tree by calling your merge function
-}
tree :: String -> Maybe HTree
tree "" = Nothing
tree str = merge (Prelude.map (\(a,b) -> Leaf b a) (fTable str))

{- COMMENTS for 4:
1. Return Nothing if the input is empty.
2. Using the created function fTable, construct the frequency table for str.
3. Function map is used to turn the frequncy table into a Leaf.
4. Using the created function merge to merge list into a single tree.
-}



-- Use these functions to pretty-print your trees

toDataTree (Leaf i c) = Node (showLeafData c i) []
toDataTree (Branch i l r) = Node (show i) [toDataTree l, toDataTree r]

showLeafData x y = (show x)++":"++(show y)

printTree t = putStrLn $ drawTree $ toDataTree t

-----------------------------------
-- TESTS
-----------------------------------

isSorted :: FreqTable -> Bool
isSorted [] = True
isSorted [x] = True
isSorted (x:xs) = if snd x <= (snd $ head xs) 
                  then isSorted xs else False

prop_fTable_sorted :: String -> Bool
prop_fTable_sorted xs = isSorted $ fTable xs 

prop_fTable_els :: String -> Bool
prop_fTable_els xs = and $ Prelude.map (\(c, i) -> c `elem` xs) $ fTable xs 

prop_fTable_els2 :: String -> Bool
prop_fTable_els2 xs = let cs = Prelude.map fst $ fTable xs in
                      and $ Prelude.map (\c -> c `elem` cs) xs 
countLeaves t = case t of
                 (Branch _ l r) -> (countLeaves l) + (countLeaves r)
                 (Leaf _ _)     -> 1

prop_emptyInput = isNothing $ tree ""

prop_singletonInput = Just (Leaf 1 'a') == (tree "a" >>= Just . (:[]) >>= merge )

prop_countNodes :: String -> Bool
prop_countNodes str = (length $ fTable str) == maybe 0 countLeaves (tree str)

runTests = do quickCheck prop_fTable_sorted
              quickCheck prop_fTable_els
              quickCheck prop_fTable_els2
              quickCheck prop_emptyInput
              quickCheck prop_singletonInput
              quickCheck prop_countNodes
