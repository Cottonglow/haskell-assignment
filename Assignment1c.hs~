{- 
   CI285 Introduction to Functional Propgramming
   Assignment 1c
-}
module Assignment1c where

import Data.Tree -- Used for pretty-printing trees
import Data.Maybe
import Test.QuickCheck

{- If this module is in the same folder as Assignment1b you can import
the definitions of HTrees, FreqTables and so on. Comment out the line
below if you don't want to do that.
-}
import Assignment1b

data Bit = Zero | One deriving (Show, Eq)

{- A HCodeMap is a Huffman encoding map, a list of code mappings such as
('a', [One, Zero]), where `10' is the code for the letter `a'.
-}
type HCodeMap = [(Char, [Bit])]

{- 1. Extract the code from a HTree. This is done by traversing the
tree and, for each leaf node, building up a list of Bits that represents the path
from the root node of the tree to that leaf. We add a Zero to the list each time 
we follow the left-hand child, and add a One to the list each time we follow the 
right-hand child.  -}
getChars :: HTree -> [Char]
getChars (Leaf _ c) = c 
getChars c xs = [xs ++ c]

getBits :: HTree -> [Bit]
getBits = undefined

extractCode :: HTree -> HCodeMap
extractCode t = undefined

{- 2. Construct a Huffman encoding for the input [a]. The output is a pair of a 
list of Bits (which represents the compressed input) and the Huffman encoding of
the input.
-}
encode :: String -> ([Bit], HCodeMap)
encode str = undefined

{- 3. Take a list of Bits and decode it using a Huffman encoding. To do this, match
   the shortest prefixes of the list of bits against the list of bit patterns in the 
   code. For instance, given the input `1011' and the code [('a', `0'), ('b', `01')]
   the result should be Just "aba". Return Nothing if a pattern of bits in the first
   argument doesn't matc any of the patterns in the second argument.
-}
decode :: [Bit] -> HCodeMap -> Maybe String
decode bs code = undefined
          
-- pretty printing
toDataTree (Leaf i c) = Node (showLeafData c i) []
toDataTree (Branch i l r) = Node (show i) [toDataTree l, toDataTree r]

showLeafData x y = (show x)++":"++(show y)

printTree t = putStrLn $ drawTree $ toDataTree t

-----------------------------------
-- TESTS
-----------------------------------

prop_extractCode = extractCode (Branch 5 (Leaf 2 'a') (Leaf 3 'b'))
                   == [('a',[Zero]),('b',[One])]

-- 'a' should have the shortest code in the encoding of "bananas"
prop_encode = [Zero] == (fromJust $ lookup 'a' $ snd $ encode "bananas")

prop_codec :: String -> Bool
prop_codec xs = (fromMaybe "" $ uncurry decode (encode xs)) == xs

runTests = do quickCheck prop_extractCode
              quickCheck prop_encode
              quickCheck prop_codec
